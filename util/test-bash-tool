#!/usr/bin/env bash

die() {
   echo $1 >&2
   exit 255
}

if [ -n "$PERCONA_TOOLKIT_BRANCH" ]; then
   BRANCH=$PERCONA_TOOLKIT_BRANCH
   cd $BRANCH
else
   while [ ! -f Makefile.PL ] && [ $(pwd) != "/" ]; do
      cd ..
   done
   if [ ! -f Makefile.PL ]; then
      die "Cannot find the root directory of the Percona Toolkit branch"
      exit 1
   fi
   BRANCH=`pwd`
fi

result() {
   result=$1
   if [ $result -eq 0 ]; then
      echo "ok $testno - $t"
   else
      echo "not ok $testno - $t"
      failed_tests=$(( failed_tests + 1))
      # Indent and display the first 30 lines
      diff "${GL_result}" "${GL_expected}" | sed -e 's/^/#   /' -e '30q'
   fi

   testno=$(( testno + 1))
}

# All variables are named GL_whatever so they don't get overwritten with stuff
# that happens in the functions sourced.
GL_input="/tmp/percona-toolkit"
GL_expected="/tmp/percona-toolkit-reference"
GL_result="/tmp/percona-toolkit-result"

run_test() {
   t=$1  # test file name, e.g. "group-by-all-01" for pt-diskstats

   # The format of the test file is as follows:
   # - line 1 is the shebang
   # - line 2 is the command to run, commented out
   # - argument 1 is the file to which the expected result should be printed
   # - argument 2 is the file to which the input should be printed

   # Get the command to run
   GL_cmd="$(head -n2 $t | tail -n1 | cut -b2-)"

   # Execute the file and tell it where to save the input & expected result
   if [ -x "${t}" ]; then
      ./$t "${GL_expected}" "${GL_input}"
   else
      die "$t is not executable"
   fi

   # Execute the command
   ${GL_cmd} > "${GL_result}"

   # Is the result the same as the expected result?
   diff -q "${GL_result}" "${GL_expected}" >/dev/null
   result $?

   # Clean up
   rm -f /tmp/percona-toolkit*
}

load_tests() {
   test_files="$@"
   i=0
   for t in $test_files; do
      # Return unless the test file is bash.  There may be other types of
      # files in the tool's test dir.
      if [ ! -f $t ]; then
         continue
      fi
      head -n 1 $t | grep -q bash || continue

      tests[$i]=$t
      i=$(( i + 1 ))
   done
   echo "1..$i"
}

tool=$1  # bash tool, e.g. pt-diskstats
t=$2     # optional test file, e.g. group-by-all-01
if [ -z "$tool" ]; then
   die "No tool specified"
fi

cd $BRANCH/bin
if [ ! -f $tool ]; then
   die "$tool does not exist"
fi
head -n1 $tool | grep -q bash || die "$tool is not a bash file"

# Source the tool, i.e. import its functions.
source $tool

cd $BRANCH/t/$tool
testno=1
failed_tests=0
declare -a tests
if [ -z "$t" ]; then
   # Run all the tool's tests.
   load_tests *
else
   # Run just the specified test.
   load_tests $t
fi

for t in "${tests[@]}"; do
   run_test $t
done

exit $failed_tests
